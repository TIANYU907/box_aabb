============================================================================
            Box-AABB v2 重构 + 并行优化 详细执行计划
============================================================================

一、并行优化分析总览
============================================================================

当前系统的性能瓶颈集中在三类操作上：
  1. FK 计算 (每次 ~0.1-0.5ms, 但被调用数万次)
  2. 碰撞检测 (Python 双层循环: links × obstacles)
  3. 邻接/去重叠 (O(N²) Python 循环)

根据分析，存在一个严重的性能 Bug 和多个可向量化的热循环：

┌─────────────────────────────────────────────────────────────────────────┐
│  关键发现: collision.py 的 check_box_collision 使用了慢版本 interval_fk │
│  而非 interval_fk_fast，修复后预计 box 碰撞检测加速 3-7×              │
└─────────────────────────────────────────────────────────────────────────┘


二、三层并行优化方案
============================================================================

=== Layer 1: AABB 计算层 (aabb/) ===

P0 — interval_fk 合并时修复慢路径 [5min, 容易]
  现状: collision.py import 了 interval_fk.compute_interval_aabb (AffineForm 版)
        而非 interval_fk_fast.compute_interval_aabb_fast (flat numpy 版)
  方案: 合并后只保留快速版，统一入口为 compute_interval_aabb()
  加速: 3-7× (影响每一次 find_free_box 和 validate_boxes)

P1 — 批量 FK 接口 [2-4h, 中等]
  现状: _evaluate_samples 中 for fp in samples 循环调用 robot.get_link_position
        RandomStrategy 每个 link 10000 次，全部串行 Python 调用
  方案: 新增 compute_fk_batch(robot, configs: ndarray(B,N)) → positions(B,L,3)
        用 np.einsum 做批量 DH 链乘，一次处理 B 个 config
  加速: 10-50× (采样评估阶段)
  影响: strategies/base.py _evaluate_samples, _update_extremes
        strategies/random.py _process_link

P6 — 并行 L-BFGS-B 优化 [1h, 容易]
  现状: optimize_extremes 串行运行 12 个独立 minimize (6边界×2评估链接)
  方案: ThreadPoolExecutor(12) 并行 (scipy 释放 GIL)
        合并入 strategies/base.py 时一并实现
  加速: 3-6×

PC — 预计算 DH 常量 [30min, 容易]
  现状: cos(alpha), sin(alpha) 每次 FK 重新计算
  方案: Robot.__init__ 中预计算为 numpy 数组，FK 直接索引
  加速: 10-15%

P8 — Cython 化标量 FK 函数 [3-4h, 中等]
  现状: _dh_joint_matrix + _isin/_icos 是纯标量 Python
  方案: 迁移到 _aabb_core.pyx，消除函数调用和分支预测开销
  加速: 2-3× (累积在所有 FK 路径上)
  注: 可延后，优先做 P0/P1 收益更大


=== Layer 2: Box Forest 层 (forest/) ===

P4 — 全向量化邻接图计算 [2h, 中等]
  现状: compute_adjacency 外层 for i in range(n) Python 循环
        内层已部分 numpy 化
  方案: 消除外层循环，计算 N×N×D 张量:
        overlap = np.minimum(hi[:,None,:], hi[None,:,:]) -
                  np.maximum(lo[:,None,:], lo[None,:,:])
        用布尔掩码一次性得到邻接矩阵 (稀疏格式)
  加速: 5-20× (N<500)
  注: N>1000 时内存 O(N²D) 可能过大，需要分块策略

P9 — _split 批量子节点 FK [2h, 中等]
  现状: HierAABBTree._split 串行调用 compute_fk_incremental 两次
        (左子、右子独立)
  方案: 堆叠两个子区间为 (2, N_joints, 2)，一次批量 FK
  加速: 1.5-2× (每次 split)

P10 — BoxForest.find_nearest KD-tree [1h, 容易]
  现状: O(N) 线性扫描所有 box 中心
  方案: 维护 scipy.spatial.KDTree，add_box 时增量重建 (触发阈值)
  加速: 10-100× (N>100 时显著)

PF1 — BoxForest 持久化区间数组 [1h, 中等]
  现状: add_box_direct 每次 list(self.boxes.values()) 重建 O(N) 列表
  方案: 维护 (N, D, 2) numpy 数组，add 时追加一行
        adjacency 检测直接在数组上向量化
  加速: 2-3×

PF2 — SpatialIndex 集成到 CollisionChecker [1h, 中等]
  现状: SpatialIndex 存在但未被主碰撞检测器使用
  方案: CollisionChecker 构造时，若 len(obstacles)>20 自动建立空间索引
        check_config/box_collision 先查索引筛选候选障碍物
  加速: 2-5× (障碍物多时)


=== Layer 3: 路径规划层 (planner/) ===

P2 — 向量化 check_segment_collision [1h, 容易]
  现状: for i in range(n_steps) 串行调用 check_config_collision
  方案: 生成 (n_steps, n_joints) 插值数组，调用 check_config_collision_batch
  加速: 5-10×

P3 — 向量化 check_config_collision 内循环 [1h, 容易]
  现状: Python 双层循环 links × obstacles
  方案: 预打包障碍物为 (M, 3, 2) 数组，链接 AABB 为 (L, 3, 2)
        广播 SAT 判定: (L, 1, 3) vs (1, M, 3) → (L, M) 碰撞矩阵
  加速: 3-5×

P5 — 批量 seed 采样 [1h, 容易]
  现状: _sample_seed 最多 20 次串行 retry，每次调 check_config_collision
  方案: 一次生成 (20, D) 候选数组，check_config_collision_batch 批量检测
        取第一个 free 的
  加速: 3-5× (采样阶段)

P7 — 向量化路径平滑 [1h, 容易]
  现状: smooth_moving_average 逐点 np.mean + check_config_collision
  方案: numpy 卷积一次计算所有均值，batch 碰撞检测
  加速: 5-10× (每轮平滑)

PC1 — bridge_disconnected 向量化 [1h, 中等]
  现状: O(reachable × unreachable) Python 循环 + 串行段碰撞检测
  方案: cdist 一次算完距离矩阵，batched segment collision
  加速: 5-10× (桥接阶段)

PC2 — connector 距离计算向量化 [30min, 容易]
  现状: _find_closest_box_pairs 双层 Python 循环
  方案: scipy.spatial.distance.cdist 一次完成
  加速: 10-50×


三、优先级排序 (实现路线图)
============================================================================

阶段 A: 高收益/低成本 (重构时顺手完成, 第1-2天)
────────────────────────────────────────────────
  [P0]  interval_fk 合并修复慢路径          3-7×    5min   ★★★★★
  [PC]  预计算 DH 常量                      10-15%  30min  ★★★
  [P3]  向量化 config collision 内循环      3-5×    1h     ★★★★
  [P2]  向量化 segment collision            5-10×   1h     ★★★★
  [P5]  批量 seed 采样                      3-5×    1h     ★★★
  [PC2] connector cdist                     10-50×  30min  ★★★

  预期整体加速: 3-5× (端到端)

阶段 B: 核心性能提升 (第3-4天)
────────────────────────────────────────────────
  [P1]  批量 FK 接口                        10-50×  3h     ★★★★★
  [P4]  全向量化邻接图                      5-20×   2h     ★★★★
  [P7]  向量化路径平滑                      5-10×   1h     ★★★
  [P10] KD-tree find_nearest                10×     1h     ★★★

  预期累积加速: 8-15× (端到端)

阶段 C: 进阶优化 (第5-6天)
────────────────────────────────────────────────
  [P6]  并行 L-BFGS-B                      3-6×    1h     ★★★
  [P9]  批量子节点 FK                       1.5-2×  2h     ★★
  [PF1] 持久化区间数组                      2-3×    1h     ★★
  [PF2] SpatialIndex 集成                   2-5×    1h     ★★★
  [PC1] bridge 向量化                       5-10×   1h     ★★

  预期累积加速: 10-20× (端到端)

阶段 D: Cython 加速 (可选, 第7天+)
────────────────────────────────────────────────
  [P8]  Cython 化标量 FK                    2-3×    4h     ★★
  _hier_core.pyx 整合                       (已有)

  预期上限: 15-30× (端到端，vs 旧版)


四、各阶段对应的重构任务映射
============================================================================

重构执行时，将并行优化嵌入对应模块的迁移过程中：

  aabb/ 迁移时:
    ├─ interval_fk.py 合并 → 顺手完成 [P0] 修复慢路径
    ├─ robot.py 迁移      → 顺手完成 [PC] 预计算 DH 常量
    ├─ strategies/ 迁移   → 预留 [P1] 批量 FK 接口
    └─ optimization 合并  → 预留 [P6] 并行化

  forest/ 迁移时:
    ├─ collision.py 迁移   → 顺手完成 [P3] 向量化 config collision
    │                      → 顺手完成 [P2] 向量化 segment collision
    │                      → 预留 [PF2] SpatialIndex 集成
    ├─ deoverlap.py 迁移   → 预留 [P4] 全向量化邻接图
    ├─ hier_aabb_tree 迁移 → 预留 [P9] 批量子节点 FK
    ├─ box_forest.py 迁移  → 预留 [P10] KD-tree
    │                      → 预留 [PF1] 持久化数组
    └─ scene.py (原 obstacles) → 预打包障碍物数组供 [P3] 使用

  planner/ 迁移时:
    ├─ box_rrt.py 迁移     → 顺手完成 [P5] 批量 seed 采样
    ├─ connector.py 迁移   → 顺手完成 [PC2] cdist
    │                      → 预留 [PC1] bridge 向量化
    ├─ path_smoother 迁移  → 预留 [P7] 向量化平滑
    └─ gcs_optimizer 迁移  → 无需优化 (scipy 已高效)


五、Benchmark 验证计划
============================================================================

每完成一个阶段，运行对应 benchmark 验证加速效果：

阶段 A 完成后:
  benchmark: 2DOF 100-box 场景 × 3 次
  基线: v1 (旧代码) 耗时
  目标: 3-5× 加速

阶段 B 完成后:
  benchmark: Panda 7DOF, 20 障碍物, 200 boxes × 3 次
  基线: 阶段 A 耗时
  目标: 累积 8-15×

阶段 C 完成后:
  benchmark: 完整 bench_panda_multi (5/10/15/20 障碍物)
  基线: 阶段 B 耗时
  目标: 累积 10-20×

回归测试: 每个阶段后必须全量 pytest 通过


六、风险与注意事项
============================================================================

1. 向量化正确性
   - interval 算术的 min/max 取值方向容易在向量化时搞反
   - 每个向量化函数必须有对应的标量参考实现做 cross-check
   - 测试中加入 property-based test (hypothesis) 验证等价性

2. 内存压力
   - P4 邻接图 N×N×D 张量：N=500, D=7 → 500×500×7×8B = 14MB → 可接受
   - N=2000 时 → 224MB → 需分块，设阈值 N_THRESHOLD=1000

3. Cython 构建
   - Windows 下需要 VS BuildTools C++ 编译器 (已安装)
   - CI 中 Cython 模块应为可选: try import, fallback to pure Python

4. 数值一致性
   - 向量化后的碰撞检测结果必须与标量版本一致 (保守方向不变)
   - 浮点累积误差: batch FK 用 np.einsum 精度可能与逐步链乘有微小差异
   - 添加 tolerance 参数 (默认 1e-10) 处理边界情况

5. 线程安全
   - P6 并行 optimize 各任务独立，无共享状态 → 安全
   - P9 speculative expansion 涉及树状态 → 需深拷贝或锁 → 延后
   - HierAABBTree 不是线程安全的 → 并行 find_free_box 需独立副本

6. 向后兼容
   - Robot.fingerprint() 哈希不能因重构而改变
   - 旧 .pkl 缓存文件应能被新代码读取 (或提供一次性迁移)


七、执行完成状态（2026-02-13）
============================================================================

本节记录截至当前的实际落地结果（非规划项）。

【总体结论】
- v2 重构已完成三层拆分并迁移到 src 布局：
  - v2/src/aabb
  - v2/src/forest
  - v2/src/planner
  - v2/src/common
- 旧代码未改动，所有重构工作均在 v2 下完成。

【关键性能修复与重构落地】
1) 已修复慢路径 Bug（P0）
  - 问题：check_box_collision 使用慢版 interval_fk
  - 处理：统一切换到快速区间 FK 实现（flat numpy 路径）
  - 影响：find_free_box 热路径不再走 AffineForm 慢实现

2) 已完成 P10（KD-tree 最近邻）
  - 位置：v2/src/forest/box_forest.py
  - 处理：find_nearest 增加 cKDTree 加速，保留线性兜底

3) 已完成模型拆分
  - aabb 模型：AABBEnvelopeResult / LinkAABBInfo / BoundaryConfig
  - forest 模型：Obstacle / BoxNode / PlannerConfig(forest 子集)
  - planner 模型：PlannerConfig / PlannerResult / Edge / BoxTree

4) 已删除或不迁移项（按重构约束）
  - 未迁移：hier_aabb_tree_old.py, strategies/hybrid.py, free_space_tiler.py
  - AABBResult 已从 v2 的 aabb 模型中移除

【配套完整性】
1) tests
  - v2/tests/aabb
  - v2/tests/forest
  - v2/tests/planner

2) benchmarks
  - v2/benchmarks/aabb/bench_interval_fk.py
  - v2/benchmarks/forest/bench_nearest_kdtree.py
  - v2/benchmarks/planner/bench_gcs_fallback.py

3) examples
  - v2/examples/aabb_demo.py
  - v2/examples/forest_demo.py
  - v2/examples/planning_demo.py

4) docs
  - v2/doc/aabb.md
  - v2/doc/forest.md
  - v2/doc/planner.md

5) 输出规范
  - 统一工具：v2/src/common/output.py
  - 输出目录：v2/output/{reports|benchmarks|visualizations|plans}/...

【验证结果】
1) 自动化测试
  - 命令：python -m pytest v2/tests -q --tb=short
  - 结果：10 passed

2) 示例 smoke
  - v2.examples.aabb_demo：成功，报告写入 v2/output/reports
  - v2.examples.forest_demo：成功，forest.pkl 写入 v2/output/reports
  - v2.examples.planning_demo：可执行，当前示例场景返回“图搜索未找到路径”（算法结果，不是运行错误）

3) 基准 smoke
  - v2.benchmarks.aabb.bench_interval_fk：成功，产出 result.txt
  - v2.benchmarks.forest.bench_nearest_kdtree：成功，产出 result.txt
  - v2.benchmarks.planner.bench_gcs_fallback：成功，产出 result.txt

【已知剩余优化（未做，不影响当前可用性）】
- P1 批量 FK 接口
- P4 全向量化邻接图（N×N×D + 分块）
- P5 批量 seed 采样
- P7 向量化路径平滑
- PF1 持久化区间数组
- PF2 SpatialIndex 集成主碰撞路径
- P8 Cython 化 aabb 标量 FK

【下一步建议】
1. 先做 P4（邻接图全向量化）+ 回归测试
2. 再做 P5（批量 seed）+ planner 端到端 benchmark
3. 最后做 P1（批量 FK）作为阶段性性能冲刺
