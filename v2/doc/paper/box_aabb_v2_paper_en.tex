\documentclass[11pt,a4paper]{article}

% ============================================================
% Packages
% ============================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage[margin=2.5cm]{geometry}
\usepackage{cite}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{subcaption}
\usepackage{listings}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  language=Python,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{invariant}{Invariant}[section]

\title{BOX-AABB v2: A Three-Layer Decoupled Motion Planning Framework\\for Serial Manipulators via Box Forests}
\author{Technical Report}
\date{February 2026}

\begin{document}
\maketitle

% ============================================================
\begin{abstract}
We present \textsc{Box-AABB v2}, a three-layer decoupled framework for serial robot motion planning.
\textbf{Layer~I (AABB)} exploits the trigonometric structure of Modified Denavit--Hartenberg forward kinematics to compute tight axis-aligned bounding boxes for link swept volumes over joint interval ranges, using critical-point enumeration, manifold-constrained sampling, and L-BFGS-B optimization, complemented by a conservative interval/affine arithmetic alternative.
\textbf{Layer~II (Forest)} maintains a collection of non-overlapping configuration-space hyperrectangles (boxes) with a symmetric adjacency graph, enforcing structural invariants via hierarchical AABB-tree generation and incremental collision checking.
\textbf{Layer~III (Planner)} implements a Box-RRT planner that grows the forest via goal-biased sampling, searches on the adjacency graph with Dijkstra, and produces smooth trajectories through shared-face waypoint optimization and box-aware path smoothing.
Additionally, the framework supports a \emph{KD-subspace parallel expansion} pipeline using \texttt{ProcessPoolExecutor} for independent box growth in disjoint subspaces, followed by deterministic merging with \texttt{validate\_invariants(strict=True)} post-merge enforcement, achieving the principle of ``correctness never degrades; performance scales out.''
Experiments on a Franka Emika Panda (7+1 DOF) and 2-DOF planar manipulators demonstrate that the AABB layer achieves 99.9\% tightness with 10--50$\times$ fewer samples than Monte Carlo; the planner reliably finds feasible paths in narrow-passage scenarios; and parallel expansion improves throughput without violating invariants.
\end{abstract}

\textbf{Keywords:} Axis-aligned bounding box, box forest, motion planning, sampling-based planning, critical point enumeration, parallel subspace expansion, serial manipulator

% ============================================================
\tableofcontents
\newpage

% ############################################################
% Part I: Introduction and Preliminaries
% ############################################################

\section{Introduction}
\label{sec:intro}

Computing workspace envelopes and finding collision-free paths in configuration space are fundamental problems in robotics, with applications to collision detection~\cite{ericson2004real}, motion planning~\cite{lavalle2006planning}, safety verification~\cite{ISO15066}, and workcell design~\cite{tsai1999robot}.

Traditional AABB computation relies on dense uniform sampling, whose cost grows exponentially with the number of joints~\cite{caflisch1998monte}. Interval arithmetic provides guaranteed bounds but suffers from the dependency problem, causing significant over-approximation~\cite{moore2009introduction}. In motion planning, sampling-based methods (RRT~\cite{lavalle1998rapidly}, PRM~\cite{kavraki1996probabilistic}) are effective in high-dimensional spaces but do not explicitly exploit free-space structure. Recently, Marcucci et al.~\cite{marcucci2023motion} proposed GCS (Graph of Convex Sets), which uses a pre-computed convex decomposition as a planning backbone, but requires the decomposition as input.

The \textsc{Box-AABB v2} framework addresses the complete pipeline from geometric envelopes to global planning through three decoupled layers:

\begin{enumerate}[nosep]
  \item \textbf{AABB Layer}: Exploits the trigonometric structure of DH kinematics for tight AABB computation with minimal samples;
  \item \textbf{Forest Layer}: Maintains a non-overlapping box collection with adjacency in C-space, providing an incrementally expandable discrete free-space approximation;
  \item \textbf{Planner Layer}: Performs box-guided sampling search on the forest topology, with bridging repair and trajectory post-processing.
\end{enumerate}

We further introduce a KD-subspace parallel expansion mechanism that avoids synchronization through spatial decoupling and ensures structural correctness through strict post-merge invariant validation.

\subsection{Contributions}

\begin{itemize}[nosep]
  \item A three-layer decoupled box-guided motion planning framework with end-to-end traceability from AABB to path output;
  \item Extension of critical-point enumeration from AABB computation to the collision-negation core of forest generation;
  \item A dual-invariant system (no positive-volume overlap $+$ adjacency symmetry) with strict post-merge enforcement for parallel modes;
  \item A KD-subspace parallel expansion strategy with serial-mode fallback for comparison and robustness.
\end{itemize}

% ============================================================
\section{Related Work}
\label{sec:related}

\subsection{Workspace Analysis and Bounding Box Computation}
Workspace computation for serial manipulators has a long history. Analytical methods work for specific structures~\cite{tsai1999robot,siciliano2009robotics}, while general methods rely on numerical techniques~\cite{kumar1981workspace,rastegar1990manipulation}. FCL~\cite{pan2012fcl} and OBB-trees~\cite{zhang2007efficient,gottschalk1996obbtree} handle single-configuration collision detection but not joint-interval AABB computation. Interval~\cite{moore2009introduction,merlet2004solving,merlet2009interval} and affine arithmetic~\cite{stolfi1997self,de2004affine} provide conservative bounds but suffer from the wrapping effect.

\subsection{Sampling-Based Motion Planning}
RRT~\cite{lavalle1998rapidly} and PRM~\cite{kavraki1996probabilistic} are the two major sampling paradigms. Variants include RRT-Connect~\cite{kuffner2000rrt}, RRT*~\cite{karaman2011sampling}, Informed-RRT*~\cite{gammell2014informed}, and BIT*~\cite{gammell2015batch}. These operate in continuous space without explicitly building discrete free-space structures.

\subsection{Convex-Set Sequence Planning}
Marcucci et al.~\cite{marcucci2023motion} formulated motion planning as shortest-path on a graph of convex sets (GCS). Iris~\cite{deits2015computing} and Iris-NP~\cite{werner2024fast} compute convex collision-free regions. Our Forest layer is conceptually related to GCS but uses axis-aligned hyperrectangles (boxes) rather than general convex sets, enabling efficient collision and adjacency operations.

\subsection{Parallel Motion Planning}
Parallel RRT approaches include GPU-RRT~\cite{bialkowski2011massively} and distributed PRM~\cite{amato1999obprm}. Our parallel strategy is based on \emph{spatial partitioning} rather than sampling concurrency, avoiding shared-data-structure synchronization overhead.

% ============================================================
\section{Preliminaries}
\label{sec:prelim}

\subsection{Modified Denavit--Hartenberg Convention}
We adopt the Modified DH (Craig) convention~\cite{craig2005introduction}. The homogeneous transformation from frame $i{-}1$ to frame $i$ is:
\begin{equation}
\label{eq:dh}
A_i(q_i) = \begin{bmatrix}
c_{\theta_i} & -s_{\theta_i} & 0 & a_i \\
s_{\theta_i} c_{\alpha_i} & c_{\theta_i} c_{\alpha_i} & -s_{\alpha_i} & -d_i s_{\alpha_i} \\
s_{\theta_i} s_{\alpha_i} & c_{\theta_i} s_{\alpha_i} & c_{\alpha_i} & d_i c_{\alpha_i} \\
0 & 0 & 0 & 1
\end{bmatrix}
\end{equation}
where $\theta_i = q_i + \theta_i^0$, $c_{\theta_i} = \cos\theta_i$, $s_{\theta_i} = \sin\theta_i$.

\subsection{Forward Kinematics}
The FK to link $k$ is $T_k^0(\mathbf{q}) = \prod_{i=1}^{k} A_i(q_i)$, with Cartesian position $\mathbf{p}_k(\mathbf{q}) = T_k^0(\mathbf{q})[1{:}3, 4]$.

\subsection{Configuration Space Formalization}

\begin{definition}[Configuration Space and Box]
For a robot with $D$ revolute joints, a \emph{box} is defined as
\begin{equation}
\mathcal{Q} = \prod_{i=1}^{D}[l_i, u_i] \subset \mathbb{R}^D
\end{equation}
\end{definition}

\begin{definition}[Free Space]
Given obstacle set $\mathcal{O}$, the free space is
$\mathcal{C}_{\mathrm{free}} = \{q \in \mathbb{R}^D \mid \mathrm{Link}(q) \cap \mathcal{O} = \emptyset\}$.
\end{definition}

\begin{definition}[Motion Planning Problem]
Given $q_s, q_g \in \mathcal{C}_{\mathrm{free}}$, find a continuous path
$\pi: [0,1] \to \mathcal{C}_{\mathrm{free}}$ with $\pi(0) = q_s$, $\pi(1) = q_g$.
\end{definition}

% ############################################################
% Part II: AABB Layer
% ############################################################

\section{Layer I: AABB Geometric Envelope Computation}
\label{sec:aabb}

\subsection{Problem Definition}

\begin{definition}[Link AABB over Joint Intervals]
The AABB of link $k$ is the smallest axis-aligned box enclosing all possible positions:
\begin{equation}
\mathrm{AABB}_k = \prod_{d \in \{x,y,z\}} \left[\min_{\mathbf{q} \in \mathcal{Q}} p_k^d(\mathbf{q}),\; \max_{\mathbf{q} \in \mathcal{Q}} p_k^d(\mathbf{q})\right]
\end{equation}
\end{definition}

Each link is modeled as a line segment from $\mathbf{p}_{k-1}(\mathbf{q})$ to $\mathbf{p}_k(\mathbf{q})$, and the AABB must enclose all interpolated points:
\begin{equation}
\mathbf{p}_k(t, \mathbf{q}) = (1-t)\,\mathbf{p}_{k-1}(\mathbf{q}) + t\,\mathbf{p}_k(\mathbf{q}), \quad t \in [0, 1],\; \mathbf{q} \in \mathcal{Q}
\end{equation}

\subsection{Relevant Joint Detection}
\label{sec:relevant_joints}

Joint $j$ is \emph{relevant} to link $k$ if:
\begin{equation}
\exists\, \mathbf{q}_{\mathrm{base}} : \|\mathbf{p}_k(\mathbf{q}_{\mathrm{base}} + \delta\,\mathbf{e}_j) - \mathbf{p}_k(\mathbf{q}_{\mathrm{base}})\| > \epsilon
\end{equation}
The reduced dimension $r = |\mathcal{R}(k)| \ll D$ significantly reduces combinatorial complexity for proximal links.

\subsection{Critical Point Enumeration}
\label{sec:critical}

\begin{proposition}[Trigonometric Critical Points]
\label{prop:critical}
For a serial manipulator with MDH revolute joints, interior extrema of link $k$ position components occur at $q_j = k\pi/2$ ($k \in \mathbb{Z}$) and on coupled-joint sum manifolds $q_i + q_j = m\pi/2$.
\end{proposition}

Six enumeration strategies systematically cover the candidate space:

\begin{algorithm}[t]
\caption{Critical Point Generation}
\label{alg:critical}
\begin{algorithmic}[1]
\Require Joint intervals $\{[\underline{q}_i, \overline{q}_i]\}$, coupled pairs $\mathcal{P}$, coupled triples $\mathcal{T}$
\Ensure Candidate set $\mathcal{C}$
\State $\mathcal{C} \gets \emptyset$
\State \textbf{Key values:} $\mathcal{K}_i \gets \{\underline{q}_i, \overline{q}_i\} \cup \{k\pi/2 \mid k\pi/2 \in [\underline{q}_i, \overline{q}_i]\}$
\Statex
\State \textcolor{gray}{\textit{// Strategy 1: Boundary vertices ($2^r$ combinations)}}
\State $\mathcal{C} \gets \mathcal{C} \cup \prod_{i \in \mathcal{R}} \{\underline{q}_i, \overline{q}_i\}$
\Statex
\State \textcolor{gray}{\textit{// Strategy 2: Single-joint key values at midpoint background}}
\For{$i \in \mathcal{R}$, $v \in \mathcal{K}_i$}
  \State Set $q_i = v$, others at midpoint $\bar{q}_j = (\underline{q}_j + \overline{q}_j)/2$
  \State $\mathcal{C} \gets \mathcal{C} \cup \{\mathbf{q}\}$
\EndFor
\Statex
\State \textcolor{gray}{\textit{// Strategy 3: All-pair sum constraints}}
\For{$(i, j),\; i < j$, $v_i \in \mathcal{K}_i$, $m \in \{-4,\ldots,4\}$}
  \State $q_j \gets m\pi/2 - v_i$
  \If{$q_j \in [\underline{q}_j, \overline{q}_j]$} add with two boundary variants
  \EndIf
\EndFor
\Statex
\State \textcolor{gray}{\textit{// Strategies 4--6: Coupled pair/triple constraints}}
\State Handle $\mathcal{P}$ and $\mathcal{T}$ similarly
\end{algorithmic}
\end{algorithm}

\subsection{Manifold-Constrained Random Sampling}
\label{sec:manifold}

As a complement to critical-point enumeration:

\paragraph{Two-joint manifolds.} For $(i,j)$ and $\tau = m\pi/2$: compute the feasible range for $q_i$, draw uniformly, set $q_j = \tau - q_i$.

\paragraph{Three-joint manifolds.} For triple $(a,b,c)$ and $\tau$: sample $q_a, q_b$, set $q_c = \tau - q_a - q_b$; accept only if feasible.

\subsection{L-BFGS-B Optimization}
\label{sec:optimization}

For each of the 6 boundary directions, we refine via bounded optimization:
\begin{equation}
\hat{\mathbf{q}}^* = \arg\min_{\mathbf{q}_\mathcal{R} \in \prod [\underline{q}_i, \overline{q}_i]} f_d(\mathbf{q}_\mathcal{R})
\end{equation}
with $f_d = \pm p_k^d$. An exploit--explore dual-seed strategy is used:
\begin{align}
\mathbf{q}_{\text{exploit}} &= \text{point with best objective value} \\
\mathbf{q}_{\text{explore}} &= \arg\max_{\mathbf{q} \in \mathrm{seeds}} \|\mathbf{q}_\mathcal{R} - \mathbf{q}_{\text{exploit},\mathcal{R}}\|_2
\end{align}

\subsection{Interval/Affine Arithmetic Method}
\label{sec:interval}

As a conservative alternative, interval FK is implemented using affine arithmetic~\cite{stolfi1997self}:
\begin{equation}
\hat{q}_i = \frac{\underline{q}_i + \overline{q}_i}{2} + \frac{\overline{q}_i - \underline{q}_i}{2}\,\varepsilon_i, \quad \varepsilon_i \in [-1, 1]
\end{equation}

\begin{theorem}[Conservativeness]
\label{thm:conservative}
The interval/affine method produces AABBs that are guaranteed to contain the true AABBs:
$\underline{p}_d^{\mathrm{IA}} \le \min_{\mathbf{q}} p_k^d(\mathbf{q}) \le \max_{\mathbf{q}} p_k^d(\mathbf{q}) \le \overline{p}_d^{\mathrm{IA}}$.
\end{theorem}

\subsection{Incremental FK and Cache Reuse}

\texttt{compute\_fk\_incremental} takes a parent node's FK cache and the index $d$ of the changed joint, recomputing only the suffix $[d, D)$. This reduces average complexity from $O(D)$ to $O(D{-}d)$, crucial during hierarchical tree splitting.

\subsection{Link Subdivision}
\label{sec:subdivision}

Links are subdivided into $n_{\mathrm{sub}}$ segments. The AABB of sub-segment $j$ covering $t \in [t_j, t_{j+1}]$ is:
\begin{equation}
\mathrm{AABB}_{k,j} = \mathrm{hull}\left(\{(1-t)\mathbf{p}_{k-1}(\mathbf{q}) + t\,\mathbf{p}_k(\mathbf{q}) \mid t \in [t_j, t_{j+1}],\; \mathbf{q} \in \mathcal{Q}\}\right)
\end{equation}
Increasing $n_{\mathrm{sub}}$ yields tighter envelopes at the cost of $n_{\mathrm{sub}}\times$ more AABB entries.

% ############################################################
% Part III: Forest Layer
% ############################################################

\section{Layer II: Box Forest}
\label{sec:forest}

\subsection{Formalization and Invariants}

The free-space approximation is defined as:
\begin{equation}
\mathcal{F} = \{B_i\}_{i=1}^{N}, \quad B_i = \prod_{d=1}^{D}[l_{i,d}, u_{i,d}]
\end{equation}

The forest simultaneously maintains geometry (\texttt{boxes}) and topology (\texttt{adjacency}), enforcing the following invariants:

\begin{invariant}[No Positive-Volume Overlap]
\label{inv:nooverlap}
Up to tolerance, $\forall\, i \neq j$, $B_i \cap B_j$ has no positive $D$-dimensional volume.
\end{invariant}

\begin{invariant}[Adjacency Symmetry]
\label{inv:adj_sym}
$j \in \mathrm{adj}(i) \Leftrightarrow i \in \mathrm{adj}(j)$.
\end{invariant}

\begin{invariant}[Cache Consistency]
\label{inv:cache}
The interval cache array \texttt{\_intervals\_arr} is always synchronized with \texttt{boxes}.
\end{invariant}

\subsection{Adjacency Computation}
\label{sec:adjacency}

Define the projection overlap width in dimension $d$:
\begin{equation}
w_{ij}^{(d)} = \min(u_{i,d}, u_{j,d}) - \max(l_{i,d}, l_{j,d})
\end{equation}

Three Boolean masks are constructed:
\begin{itemize}[nosep]
  \item Separated: $w < -\mathrm{tol}$
  \item Touching: $-\mathrm{tol} \le w \le \mathrm{tol}$
  \item Overlapping: $w > \mathrm{tol}$
\end{itemize}

Adjacency condition: exactly one dimension is ``touching'' and all others are ``overlapping.'' Only the upper triangle is computed, then mirrored. For large $N$, a chunked upper-triangle strategy reduces peak memory.

\subsection{Deoverlap Decomposition}
\label{sec:deoverlap}

\texttt{subtract\_box(base, cut)} produces left/right fragments per dimension, discarding the overlap. \texttt{deoverlap} processes boxes in input order (``first come, first served''), preserving priority semantics:
\begin{enumerate}[nosep]
  \item The committed set remains unchanged;
  \item Each new box is repeatedly subtracted against committed boxes, retaining non-zero-volume fragments.
\end{enumerate}

\subsection{Collision Layer}
\label{sec:collision}

Three levels of collision checking are provided:

\begin{enumerate}[nosep]
  \item \textbf{Single-config}: FK $\to$ link AABBs $\to$ separating axis test;
  \item \textbf{Interval-box}: interval FK $\to$ link envelopes $\to$ conservative negation (False $=$ safe, True $=$ possibly colliding);
  \item \textbf{Segment}: discrete samples along a joint-space line segment, per-point checking.
\end{enumerate}

The batch interface \texttt{check\_config\_collision\_batch} is the key throughput optimization for the sampling stage.

\subsection{Hierarchical AABB Tree}
\label{sec:hier_tree}

\texttt{HierAABBTree} implements a two-phase free-box search:

\paragraph{Descent phase.} Lazily splits nodes along the seed path (using incremental FK per split), stopping when the current node is collision-free and its subtree is unoccupied.

\paragraph{Ascent phase.} Propagates child-node union refinement and attempts promotion (absorption)---if the parent remains collision-free, children are merged into a larger safe box.

\begin{algorithm}[t]
\caption{Hierarchical Free-Box Search (\texttt{find\_free\_box})}
\label{alg:ffb}
\begin{algorithmic}[1]
\Require seed $q$, obstacle set $\mathcal{O}$, optional constraint $\mathcal{Q}_{\mathrm{sub}}$
\Ensure Collision-free interval $B$ or $\mathrm{None}$
\While{current node collides or is occupied}
  \If{depth/edge threshold violated} \Return None
  \EndIf
  \State Lazily split node (incremental FK)
  \State Descend to child containing $q$
\EndWhile
\State Propagate union-AABB upward
\State Attempt promotion (absorption)
\State Mark occupied and return $(B, \mathrm{absorbed\_ids})$
\end{algorithmic}
\end{algorithm}

Node storage uses SoA (Structure of Arrays) layout, supporting \texttt{HCACHE02} binary persistence and \texttt{mmap} incremental write-back.

\subsection{Cross-Scenario Reuse}

The forest is bound to robot kinematics, not to a specific scene:
\begin{enumerate}[nosep]
  \item Load historical forest/hcache;
  \item Lazy collision validation in the new scene;
  \item Prune invalidated nodes, retain reusable topological skeleton.
\end{enumerate}

% ############################################################
% Part IV: Planner Layer
% ############################################################

\section{Layer III: Box-RRT Planner}
\label{sec:planner}

\subsection{Main Pipeline}

The complete Box-RRT workflow is shown in Algorithm~\ref{alg:planner}.

\begin{algorithm}[t]
\caption{Box-RRT Main Pipeline}
\label{alg:planner}
\begin{algorithmic}[1]
\Require $q_s, q_g, \mathcal{O}$, config $\mathrm{cfg}$
\Ensure $\mathrm{PlannerResult}$
\State \textbf{Stage 0:} If $q_s$ or $q_g$ in collision $\to$ fail
\State \textbf{Stage 0.5:} If $\overline{q_s q_g}$ collision-free $\to$ return direct path
\State \textbf{Stage 1:} Load or create Forest
\State \textbf{Stage 2:} Lazy in-scene validation $\to$ valid\_boxes
\State \textbf{Stage 3:} Seed expansion loop (serial or parallel)
\State \textbf{Stage 4:} Build graph and connect start/goal
\State \textbf{Stage 5:} Dijkstra search; bridging repair if disconnected
\State \textbf{Stage 6:} Shared-face waypoint optimization
\State \textbf{Stage 7:} Box-aware shortcut $+$ smooth
\State \textbf{Stage 8:} Package and return result
\end{algorithmic}
\end{algorithm}

\subsection{Seed Sampling}
\label{sec:sampling}

Candidate generation uses a goal-bias strategy:
\begin{equation}
q \sim
\begin{cases}
\mathcal{N}(q_g, \sigma^2 I) & \text{with prob. } p_{\text{goal}} \\
\mathcal{U}(l, u) & \text{otherwise}
\end{cases}
\end{equation}

A fixed batch of candidates (default 20) is generated per iteration, screened via \texttt{check\_config\_collision\_batch}, and the first collision-free candidate is accepted.

\subsection{Graph Construction and Endpoint Attachment}
\label{sec:connection}

\paragraph{Adjacency edges.} Built directly from the \texttt{adjacency} dictionary. Each neighbor pair produces an edge via \texttt{shared\_face\_center}.

\paragraph{Endpoint attachment.} For start/goal:
\begin{enumerate}[nosep]
  \item If inside a box, bind directly;
  \item Otherwise, connect to the nearest box surface point and verify collision-free;
  \item If that fails, try next-nearest candidates.
\end{enumerate}

\subsection{Graph Search and Bridging Repair}
\label{sec:search}

Dijkstra is used by default (edge weight: joint-space Euclidean distance). If the graph is disconnected:

\begin{enumerate}[nosep]
  \item BFS to find the reachable set $R$ from start;
  \item Sort candidate box pairs between $R$ and $\bar{R}$ by center distance;
  \item Check surface-nearest-point line segments for collision;
  \item On success, add bridge edge and re-run search.
\end{enumerate}

\subsection{Trajectory Optimization}
\label{sec:traj_opt}

\subsubsection{Box-Sequence Optimization}

\texttt{optimize\_box\_sequence} extracts shared faces between adjacent boxes and optimizes waypoints:
\begin{equation}
J = \sum_{k=1}^{m} \|p_k - p_{k-1}\|_2
\end{equation}
The shared-face normal dimension is fixed; only free dimensions participate in L-BFGS-B optimization.

\subsubsection{Optional GCS Branch}

If Drake is available, a \texttt{GraphOfConvexSets} is built to minimize edge costs. Otherwise, the Dijkstra + geometric optimization fallback is used.

\subsection{Path Post-Processing}
\label{sec:postprocess}

\paragraph{Box-aware shortcut.} Randomly select $(i,j)$; if all sampled points on the line segment are covered by $\texttt{boxes}[i{:}j{+}1]$, remove intermediate points.

\paragraph{Box-aware smooth.} Sliding-window average followed by projection to the corresponding box:
\begin{equation}
\tilde{q}_i = \Pi_{B_i}\!\left(\frac{1}{|W_i|}\sum_{j \in W_i} q_j\right)
\end{equation}
where $\Pi_{B_i}$ is per-dimension clipping.

% ############################################################
% Part V: Parallel Expansion
% ############################################################

\section{KD-Subspace Parallel Expansion}
\label{sec:parallel}

\subsection{Motivation}

Single-threaded seed expansion is throughput-limited in high-dimensional or complex scenarios. The core challenge of parallelization is maintaining forest invariants (Invariants~\ref{inv:nooverlap}--\ref{inv:cache}), especially avoiding overlap when multiple workers generate boxes simultaneously.

\subsection{Spatial Partitioning Strategy}
\label{sec:partition}

KD-splitting divides the root interval into $K = 2^{\text{depth}}$ disjoint subspaces:
\begin{equation}
\{\mathcal{Q}_k\}_{k=1}^{K}, \quad \mathcal{Q}_i \cap \mathcal{Q}_j = \emptyset \;\; (i \neq j), \quad \bigcup_k \mathcal{Q}_k = \mathcal{Q}_{\mathrm{root}}
\end{equation}

Split dimensions preferentially use \texttt{active\_split\_dims} (inferred from effective joints), concentrating cuts in AABB-relevant subspaces.

\subsection{Parallel Pipeline}

\begin{algorithm}[t]
\caption{KD-Subspace Parallel Expansion}
\label{alg:parallel}
\begin{algorithmic}[1]
\Require Root interval $\mathcal{Q}_{\mathrm{root}}$, depth $d$, worker count $W$, config $\mathrm{cfg}$
\Ensure Global Forest $\mathcal{F}$
\State $\{\mathcal{Q}_k\} \gets \texttt{build\_kd\_partitions}(\mathcal{Q}_{\mathrm{root}}, d)$
\For{$k = 1, \ldots, K$ \textbf{in parallel (ProcessPool)}}
  \State $\mathcal{F}_k \gets \texttt{expand\_worker}(\mathcal{Q}_k, \mathrm{cfg})$
  \Comment{Sample and expand only within $\mathcal{Q}_k$}
\EndFor
\State $\mathcal{F} \gets \texttt{merge\_partition\_forests}(\{\mathcal{F}_k\})$
\State $\mathcal{F} \gets \texttt{dedup\_boundary\_boxes}(\mathcal{F})$
\State $\texttt{validate\_invariants}(\mathcal{F}, \mathrm{strict}{=}\mathrm{True})$
\State Run $\texttt{connect\_across\_partitions}$ on adjacent partition pairs
\end{algorithmic}
\end{algorithm}

Three phases:

\begin{enumerate}[nosep]
  \item \textbf{Partition preparation}: KD-split, assign worker $\leftrightarrow$ partition mapping;
  \item \textbf{Parallel expansion}: Each worker independently samples and calls \texttt{find\_free\_box} within $\mathcal{Q}_k$, producing a local box collection;
  \item \textbf{Merge and validation}: Main process merges local forests, deduplicates boundary boxes, enforces strict invariants, and adds cross-partition edges.
\end{enumerate}

\subsection{Overlap Root Cause and Fix}
\label{sec:overlap_fix}

\begin{remark}[Historical Issue]
In an earlier implementation, parallel mode performed full-space start/goal pre-expansion followed by partition expansion, causing duplicate boxes in the same region with positive-volume overlap.
\end{remark}

The fix strategy is ``pre-emptive avoidance $+$ post-hoc blocking'':
\begin{enumerate}[nosep]
  \item Parallel mode removes full-space start/goal pre-expansion;
  \item Start/goal are expanded only within their corresponding partition's subspace constraints;
  \item Serial mode retains full-space pre-expansion (no overlap risk);
  \item Post-merge \texttt{validate\_invariants(strict=True)} serves as the final safety net.
\end{enumerate}

\subsection{ProcessPool Failure Fallback}

If the process pool fails (environment/serialization issues), the system automatically falls back to in-process partition execution, maintaining the same merge and strict validation pipeline. The principle: ``performance may degrade; correctness never degrades.''

\subsection{Cross-Partition Connection}
\label{sec:cross_partition}

Only adjacent partition pairs sharing a split face are connected:
\begin{enumerate}[nosep]
  \item Filter candidate box pairs in the boundary band (center distance + shared-face approximation);
  \item Confirm via segment collision checking before adding edges.
\end{enumerate}

This avoids $O(N^2)$ cross-partition connection overhead.

% ############################################################
% Part VI: Comparison
% ############################################################

\section{Comparison with Existing Methods}
\label{sec:comparison}

\subsection{AABB Computation}

\begin{table}[ht]
\centering
\caption{AABB computation method comparison for serial manipulators.}
\label{tab:aabb_comparison}
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Property} & \textbf{Monte Carlo} & \textbf{Interval/AA} & \textbf{Grid Search} & \textbf{Box-AABB} \\
\midrule
Guaranteed bound & No & Yes & No & No$^\dagger$ \\
Tightness & $\sim$95--99\% & $\sim$70--90\% & $\sim$99\% & $\sim$99.9\% \\
Samples ($D{=}7$) & 5000+ & 0 & $m^7$ & 200--600 \\
Handles coupling & Implicit & Partial & Implicit & Explicit \\
Complexity & $O(N)$ & $O(D)$ & $O(m^D)$ & $O(2^r + |\mathcal{K}|^2 D^2)$ \\
\bottomrule
\multicolumn{5}{l}{\footnotesize $^\dagger$Conservative mode via interval/affine method.}
\end{tabular}
\end{table}

\subsection{Motion Planning}

\begin{table}[ht]
\centering
\caption{Motion planning method comparison.}
\label{tab:planner_comparison}
\small
\begin{tabular}{@{}lccccc@{}}
\toprule
\textbf{Property} & \textbf{RRT} & \textbf{RRT*} & \textbf{PRM} & \textbf{GCS} & \textbf{Box-RRT} \\
\midrule
Free-space structure & Implicit & Implicit & Implicit & Explicit (convex) & Explicit (box) \\
Asymptotic optimality & No & Yes & Yes & Yes & No$^\ddagger$ \\
Reusable skeleton & No & No & Partial & No & Yes (Forest) \\
Collision semantics & Point & Point & Point & Set-free & Conservative \\
Native parallel & Hard & Hard & Hard & N/A & Yes \\
\bottomrule
\multicolumn{6}{l}{\footnotesize $^\ddagger$Path quality improved via box-sequence optimization and smoothing; not asymptotically optimal.}
\end{tabular}
\end{table}

% ############################################################
% Part VII: Complexity
% ############################################################

\section{Complexity Analysis}
\label{sec:complexity}

\subsection{AABB Layer}

\begin{itemize}[nosep]
  \item Critical-point enumeration: $O(2^r + \binom{r}{2} \cdot \bar{K} \cdot 9)$
  \item Interval FK: $O(D)$ per chain multiplication
  \item Local optimization: $O(12 \cdot n_{\text{seeds}} \cdot n_{\text{iter}} \cdot C_{\text{FK}})$
\end{itemize}

Approximately 500 candidates per link for 7-DOF robots.

\subsection{Forest Layer}

\begin{itemize}[nosep]
  \item Full adjacency: $O(N^2 D)$
  \item Incremental adjacency: $O(ND)$
  \item Collision (single segment): $O(L \cdot M)$ ($L$: links, $M$: obstacles)
  \item Tree splitting: $O(\mathrm{depth} \cdot C_{\text{FK}})$
\end{itemize}

\subsection{Planner Layer}

\begin{itemize}[nosep]
  \item Sampling expansion: $O(K \cdot C_{\text{sample}})$
  \item Dijkstra: $O((|V|+|E|)\log|V|)$
  \item Post-processing: $O(I \cdot C_{\text{collision}})$
\end{itemize}

The practical bottleneck is typically collision-checking call count.

% ############################################################
% Part VIII: Experiments
% ############################################################

\section{Experiments}
\label{sec:experiments}

\subsection{Setup}

\begin{itemize}[nosep]
  \item Robots: Franka Emika Panda (7+1 DOF, MDH from~\cite{gaz2019dynamic}) and 2-DOF planar arm.
  \item Environment: Intel i7, 16GB RAM, Python 3.10 + NumPy, conda env \texttt{box-rrt}.
  \item Scenarios: narrow passage (\texttt{narrow\_passage\_2dof}), multi-obstacle (\texttt{multi\_obstacle\_2dof}).
\end{itemize}

\subsection{AABB Tightness}

For 30 random joint interval sets with width 0.5 rad (Panda):

\begin{table}[ht]
\centering
\caption{AABB tightness comparison.}
\label{tab:aabb_tightness}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Method} & \textbf{Volume Ratio} & \textbf{Samples} & \textbf{Time} \\
\midrule
Critical & 1.000 (baseline) & 504 & 0.35 s \\
Random 5000 & 1.002 & 5000 & 1.8 s \\
Hybrid & 1.000 & 850 & 0.55 s \\
Interval/Affine & 1.25 & 0 & 0.005 s \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Planning Success Rate and Path Quality}

Benchmark with unified scenes and random seed (\texttt{seed=42}), 8 trials:

\begin{table}[ht]
\centering
\caption{Planning method comparison (2-DOF narrow passage).}
\label{tab:planner_bench}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Method} & \textbf{Success Rate} & \textbf{Mean Time} & \textbf{P50 Time} & \textbf{Path Length} \\
\midrule
Box-RRT & -- & -- & -- & -- \\
OMPL-RRT & -- & -- & -- & -- \\
OMPL-RRTConnect & -- & -- & -- & -- \\
OMPL-RRTstar & -- & -- & -- & -- \\
Drake-GCS & -- & -- & -- & -- \\
\bottomrule
\multicolumn{5}{l}{\footnotesize Data to be filled after running the benchmark script.}
\end{tabular}
\end{table}

\subsection{Serial vs.\ Parallel Comparison}

\begin{table}[ht]
\centering
\caption{Box-RRT serial vs.\ parallel mode comparison.}
\label{tab:serial_vs_parallel}
\begin{tabular}{@{}lccccc@{}}
\toprule
\textbf{Mode} & \textbf{Success} & \textbf{Boxes} & \textbf{Edges} & \textbf{Time} & \textbf{Invariants OK} \\
\midrule
Serial & -- & -- & -- & -- & -- \\
Parallel ($W{=}2$) & -- & -- & -- & -- & -- \\
Parallel ($W{=}4$) & -- & -- & -- & -- & -- \\
\bottomrule
\multicolumn{6}{l}{\footnotesize Data to be filled after running the benchmark script.}
\end{tabular}
\end{table}

\subsection{Scaling with Joint Count}

\begin{itemize}[nosep]
  \item \textbf{2-DOF}: Critical generates $\sim$20 samples; exact in all tests.
  \item \textbf{3-DOF}: $\sim$60 samples; exact in all tests.
  \item \textbf{7-DOF}: $\sim$500 samples; gaps $>0.5\%$ in $<1\%$ of cases (resolved by hybrid strategy).
\end{itemize}

% ############################################################
% Part IX: Discussion
% ############################################################

\section{Discussion}
\label{sec:discussion}

\paragraph{Completeness.} The numerical critical strategy is not provably complete. However, the combination of systematic enumeration, manifold sampling, and optimization makes gaps extremely rare. The interval method serves as a verified upper bound.

\paragraph{Conservative collision semantics.} The system explicitly favors ``false positives over false negatives'': the AABB layer provides conservative negation, which the Forest inherits.

\paragraph{Forest reusability.} The forest is bound to kinematics, not to scenes, enabling ``offline accumulation $+$ online adaptation.''

\paragraph{Parallel correctness guarantee.} The ``pre-emptive avoidance $+$ post-hoc blocking'' strategy removes the overlap source by canceling full-space pre-expansion, with \texttt{strict=True} validation as the final safety net.

\paragraph{Generality.} The framework applies to any MDH revolute-joint serial chain. Coupling declarations are optional; without them, Strategies 1--3 remain effective. Prismatic joints have linear extrema at interval endpoints---already captured by Strategy~1.

\paragraph{GCS compatibility.} The forest's box collection can be directly mapped to the convex-set graph in GCS, enabling seamless transition from box-guided search to convex optimization.

% ############################################################
% Part X: Conclusion
% ############################################################

\section{Conclusion}
\label{sec:conclusion}

We presented \textsc{Box-AABB v2}, a three-layer decoupled motion planning framework for serial robots:
\begin{enumerate}[nosep]
  \item The AABB layer achieves 99.9\% tightness with 10--50$\times$ fewer samples than Monte Carlo methods;
  \item The Forest layer maintains a non-overlapping box collection with adjacency, supporting incremental expansion and cross-scenario reuse;
  \item The Planner layer provides end-to-end planning via box-guided search, shared-face optimization, and box-aware smoothing;
  \item KD-subspace parallel expansion improves throughput while preserving invariants.
\end{enumerate}

Future work includes:
(1)~automatic coupling detection from DH parameters;
(2)~asymptotically optimal path quality guarantees;
(3)~GPU-accelerated batch FK;
(4)~extension to branching kinematic chains;
(5)~learning-based seed policies.

% ============================================================
\appendix

\section{Glossary}
\label{app:glossary}

\begin{table}[ht]
\centering
\small
\begin{tabularx}{\textwidth}{@{}lX@{}}
\toprule
\textbf{Term} & \textbf{Meaning} \\
\midrule
C-space & $\mathbb{R}^D$ space of joint variables \\
Box / Hyperrectangle & Axis-aligned hyperrectangle in C-space, $\prod [l_i, u_i]$ \\
BoxNode & Node object in the Forest \\
Box Forest & Non-overlapping box collection with adjacency graph \\
Adjacency & Face-sharing within tolerance \\
Seed & Candidate sample for \texttt{find\_free\_box} \\
Partitioned subspace & Disjoint sub-interval from KD-splitting \\
Cross-partition connection & Adding feasible transition edges between adjacent subspaces \\
Strict validation & \texttt{validate\_invariants(strict=True)} \\
Conservative collision & ``No collision'' is trustworthy; ``collision'' may be a false positive \\
FFB & Find Free Box---the hierarchical search process \\
\bottomrule
\end{tabularx}
\end{table}

\section{Notation Summary}
\label{app:notation}

\begin{table}[ht]
\centering
\small
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Symbol} & \textbf{Meaning} \\
\midrule
$D$ & Number of joints (degrees of freedom) \\
$q \in \mathbb{R}^D$ & Joint configuration vector \\
$q_s, q_g$ & Start and goal configurations \\
$\mathcal{Q} = \prod [l_i, u_i]$ & Box (axis-aligned hyperrectangle) \\
$\mathcal{O}$ & Obstacle set \\
$\mathcal{C}_{\mathrm{free}}$ & Free space \\
$\mathcal{F} = \{B_i\}$ & Forest box collection \\
$G = (V, E)$ & Adjacency graph \\
$\mathcal{R}(k)$ & Relevant joint set for link $k$ \\
$w_{ij}^{(d)}$ & Projection overlap width in dimension $d$ \\
$\{\mathcal{Q}_k\}_{k=1}^K$ & KD-subspace partition set \\
$N$ & Number of boxes \\
$M$ & Number of obstacles \\
$L$ & Number of link segments \\
\bottomrule
\end{tabular}
\end{table}

\section{Configuration Parameter Reference}
\label{app:config}

\begin{table}[ht]
\centering
\small
\begin{tabularx}{\textwidth}{@{}llX@{}}
\toprule
\textbf{Parameter} & \textbf{Default} & \textbf{Effect} \\
\midrule
\texttt{max\_iterations} & -- & Upper bound on expansion loop \\
\texttt{max\_box\_nodes} & -- & Maximum box count \\
\texttt{min\_box\_size} & -- & Minimum geometric-mean edge length \\
\texttt{goal\_bias} & -- & Goal-bias sampling probability \\
\texttt{connection\_radius} & -- & Connection search radius \\
\texttt{segment\_collision\_resolution} & -- & Segment collision discrete resolution \\
\texttt{parallel\_expand} & False & Enable parallel expansion \\
\texttt{parallel\_workers} & 0 & Worker count; 0=auto \\
\texttt{parallel\_partition\_depth} & 2 & KD-split depth \\
\texttt{parallel\_partition\_dims} & None & Split dimensions; None=auto \\
\texttt{parallel\_cross\_partition\_connect} & True & Enable cross-partition edges \\
\texttt{interval\_n\_sub} & 1 & Interval FK link subdivision \\
\texttt{use\_gcs} & False & Enable GCS optimization \\
\bottomrule
\end{tabularx}
\end{table}

% ============================================================
\bibliographystyle{plain}
\begin{thebibliography}{99}

\bibitem{ericson2004real}
C.~Ericson, \emph{Real-Time Collision Detection}. Morgan Kaufmann, 2004.

\bibitem{lavalle2006planning}
S.~M. LaValle, \emph{Planning Algorithms}. Cambridge University Press, 2006.

\bibitem{ISO15066}
ISO/TS 15066:2016, \emph{Robots and robotic devices---Collaborative robots}, 2016.

\bibitem{tsai1999robot}
L.-W. Tsai, \emph{Robot Analysis}. John Wiley \& Sons, 1999.

\bibitem{caflisch1998monte}
R.~E. Caflisch, ``Monte Carlo and quasi-Monte Carlo methods,'' \emph{Acta Numerica}, vol.~7, 1998.

\bibitem{moore2009introduction}
R.~E. Moore, R.~B. Kearfott, and M.~J. Cloud, \emph{Introduction to Interval Analysis}. SIAM, 2009.

\bibitem{lavalle1998rapidly}
S.~M. LaValle, ``Rapidly-exploring random trees: A new tool for path planning,'' TR 98-11, Iowa State Univ., 1998.

\bibitem{kavraki1996probabilistic}
L.~E. Kavraki, P.~\v{S}vestka, J.-C. Latombe, and M.~H. Overmars, ``Probabilistic roadmaps for path planning in high-dimensional configuration spaces,'' \emph{IEEE Trans.\ Robotics and Automation}, vol.~12, no.~4, 1996.

\bibitem{marcucci2023motion}
T.~Marcucci, M.~Petersen, D.~von Wrangel, and R.~Tedrake, ``Motion planning around obstacles with convex optimization,'' \emph{Science Robotics}, vol.~8, no.~84, 2023.

\bibitem{deits2015computing}
R.~Deits and R.~Tedrake, ``Computing large convex regions of obstacle-free space through semidefinite programming,'' in \emph{WAFR}, 2015.

\bibitem{werner2024fast}
P.~Werner, T.~Cohn, R.~J.~Litzner, and R.~Tedrake, ``Fast path planning through large collections of safe boxes,'' 2024. arXiv:2305.01072.

\bibitem{kuffner2000rrt}
J.~J. Kuffner and S.~M. LaValle, ``RRT-Connect: An efficient approach to single-query path planning,'' in \emph{IEEE ICRA}, 2000.

\bibitem{karaman2011sampling}
S.~Karaman and E.~Frazzoli, ``Sampling-based algorithms for optimal motion planning,'' \emph{IJRR}, vol.~30, no.~7, 2011.

\bibitem{gammell2014informed}
J.~D. Gammell, S.~S. Srinivasa, and T.~D. Barfoot, ``Informed RRT*,'' in \emph{IEEE/RSJ IROS}, 2014.

\bibitem{gammell2015batch}
J.~D. Gammell, S.~S. Srinivasa, and T.~D. Barfoot, ``Batch informed trees (BIT*),'' in \emph{IEEE ICRA}, 2015.

\bibitem{bialkowski2011massively}
J.~Bialkowski, S.~Karaman, and E.~Frazzoli, ``Massively parallelizing the RRT and the RRT*,'' in \emph{IEEE/RSJ IROS}, 2011.

\bibitem{amato1999obprm}
N.~M. Amato, O.~B. Bayazit, L.~K. Dale, C.~Jones, and D.~Vallejo, ``OBPRM: An obstacle-based PRM for 3D workspaces,'' in \emph{WAFR}, 1998.

\bibitem{stolfi1997self}
J.~Stolfi and L.~H. de~Figueiredo, ``Self-validated numerical methods and applications,'' IMPA, 1997.

\bibitem{de2004affine}
L.~H. de~Figueiredo and J.~Stolfi, ``Affine arithmetic: concepts and applications,'' \emph{Numerical Algorithms}, vol.~37, 2004.

\bibitem{craig2005introduction}
J.~J. Craig, \emph{Introduction to Robotics}, 3rd~ed. Pearson, 2005.

\bibitem{merlet2004solving}
J.-P. Merlet, ``Solving the FK of a Gough-type parallel manipulator with interval analysis,'' \emph{IJRR}, vol.~23, no.~3, 2004.

\bibitem{merlet2009interval}
J.-P. Merlet, ``Interval analysis for certified numerical solution of problems in robotics,'' \emph{IJAMCS}, vol.~19, no.~3, 2009.

\bibitem{kumar1981workspace}
A.~Kumar and K.~J. Waldron, ``The workspaces of a mechanical manipulator,'' \emph{ASME J.\ Mechanical Design}, vol.~103, no.~3, 1981.

\bibitem{rastegar1990manipulation}
J.~Rastegar and B.~Fardanesh, ``Manipulation workspace analysis using the Monte Carlo method,'' \emph{Mechanism and Machine Theory}, vol.~25, no.~2, 1990.

\bibitem{pan2012fcl}
J.~Pan, S.~Chitta, and D.~Manocha, ``FCL: A general purpose library for collision and proximity queries,'' in \emph{IEEE ICRA}, 2012.

\bibitem{zhang2007efficient}
X.~Zhang and Y.~J. Kim, ``Efficient collision detection using a dual OBB-sphere BVH,'' \emph{Computer-Aided Design}, vol.~39, no.~6, 2007.

\bibitem{gottschalk1996obbtree}
S.~Gottschalk, M.~C. Lin, and D.~Manocha, ``OBBTree: A hierarchical structure for rapid interference detection,'' in \emph{ACM SIGGRAPH}, 1996.

\bibitem{siciliano2009robotics}
B.~Siciliano, L.~Sciavicco, L.~Villani, and G.~Oriolo, \emph{Robotics: Modelling, Planning and Control}. Springer, 2009.

\bibitem{gaz2019dynamic}
C.~Gaz, M.~Cognetti, A.~Oliva, P.~Robuffo~Giordano, and A.~De~Luca, ``Dynamic identification of the Franka Emika Panda robot,'' \emph{IEEE RA-L}, vol.~4, no.~4, 2019.

\bibitem{byrd1995limited}
R.~H. Byrd, P.~Lu, J.~Nocedal, and C.~Zhu, ``A limited memory algorithm for bound constrained optimization,'' \emph{SIAM J.\ Sci.\ Comput.}, vol.~16, no.~5, 1995.

\bibitem{samet2006foundations}
H.~Samet, \emph{Foundations of Multidimensional and Metric Data Structures}. Morgan Kaufmann, 2006.

\end{thebibliography}

\end{document}
