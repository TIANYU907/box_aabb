我现在在考虑将关节空间离散化，分辨率为n，然后采用类似kd tree的空间切分思路来储存aabb包络缓存。
box拓展算法需要直接选择离散空间中的一个包含seed的box（可包含多个分辨率小方格）进行尝试。假设关节空间维度为d, 则需要2d个参数确定这个box。
2d个参数顺序需要固定。2d个参数分别为[min_1, max_1, min_2, max_2, ..., min_d, max_d]，其中min_i和max_i分别表示第i维的最小值和最大值。(是否要固定维度顺序？固定的话可以减少复杂度，但会损失box精度，不固定维度顺序则root每层的子节点过多，增加查询复杂度)
若缓存为空，则初始化box_tree为d+1层的树，从第二层开始每层切分一个维度，树结构为整个关节空间root_node->[limit_min_1, limit_max_1]->[limit_min_2, limit_max_2] ...-> [limit_min_d, limit_max_d]

取current node = root node, 并记录当前node的深度i，当前node的区间为[current_min_i, current_max_i]，迭代以下过程：
1. 查询当前node的aabb包络是否存在，如果不存在，则计算当前node的aabb包络，并加入缓存中。
2. 检查当前node的aabb包络是否与障碍物碰撞，如果不碰撞，则认为当前node对应的box是一个无碰撞的box，直接返回；
3. 如果碰撞，则需要继续细分当前node对应的box。当前node的区间[current_min_i, current_max_i]，将其切分成3个子区间：[current_min_i, min_i], [min_i, max_i], [max_i, current_max_i]，其中min_i和max_i分别为当前node区间在第i维的切分点。查询缓存中是否存在这3个子区间对应的aabb包络，如果不存在，则计算这3个子区间对应的aabb包络，并加入缓存中。然后选择包含seed的那个子区间作为新的current node，并将深度i加1。
 
作为root box[root_min_1, root_max_1, ..., root_min_d, root_max_d]，先查询生成root box的aabb包络，并加入缓存中。
然后检查是否无碰撞，如果无碰撞，认为当前root box是拓展结果, 用当前root box边界替代之前的2d个参数。
如果碰撞，则在第一个维度上查询root box是否有包含子区间[min_1,max_1, root_min_2, root_max_2, ..., root_min_d, root_max_d]的已有缓存叶子节点，如果有且数量大于等于1，则直接使用最小的子box作为新的root box继续检查碰撞；如果没有，则用min_1和max_1将root box切分成3个子box, 查询缓存中是否存在这3个子box的aabb信息, 如果没有，分别计算这3个子box的aabb包络，并加入缓存中， 作为root box的子节点，并更新。然后选择包含seed的那个子box成为新的root box。
 用min_1和max_1将root box切分成3个子box, 查询缓存中是否存在这3个子box的aabb信息, 如果没有，分别计算这3个子box的aabb包络，并加入缓存中， 作为root box的子节点，并更新。然后选择包含seed的那个子box成为新的root box。
迭代上述过程，直到找到一个无碰撞的box或者达到最大迭代次数。